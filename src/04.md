# Actix web 

# ASYNC 

## mini redis is left 
Attribute means characteristic.
A handler is routine/function/,methods which is typically specialized in a certain type of data or focused on certain special tasks.
# Rocket rust 
Routing handler are focused in routes and handler.
A handles is simply function.
Rocket main task is to listen to the web request.
Before dispatching the request rocket need to mounted.
`Routing` It refers to the route made for the data to travel the destination.
`Mount` it simply means to add the additional information. 
And before routing it is important to mount the route .
The main difference is that Web API uses the HTTP verb, not the URI path, to select the action. 
`Launching` Rockets start serving the request after being launched and it starts a multithreaded async server and dispatches the request to matching routes as they arrive.
Async run time is created to launch the server. #[launch] and #[rocket::main]are two  method to launc the server .
n REST architecture, statelessness refers to a communication method in which the server completes every client request independently of all previous requests. Clients can request resources in any order, and every request is stateless or isolated from other requests.
```Future and Async```
Rocket  use rust `Future` for concurrency .A future represents an asynchronous computation obtained by use of async.
A future is a value that might not have finished computing yet. This kind of “asynchronous value” makes it possible for a thread to continue doing useful work while it waits for the value to become available.The core method of future, poll, attempts to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it’s possible to make further progress by polling again.
```Concurrency``` Concurrency or concurrent computing refers to the form of computing in which multiple computing tasks occur simultaneously or at overlapping times.
Rocket's make it easy to use async/await .Async function make it easy to use handler.
Rust future are form of cooperative multitasking.it will .awaits on the operations and never block.
 `Methods` A Rocket route attribute can be any one of the `get ,post,put delete,head,patch or options` each correspoinding to the HTTP methods to match against.It will match against the root path .
 `HEAD Request` Rocket handles HEAD requests automatically when there exists a GET route that would otherwise match. 
` Dynamics Paths` You can declare path segements as dynamic by using angel brackets around the variable.
`URI` It stands for the uniform resource identifier. URL AND URN are the further parts of these things .
# API  endpoint 
 An Api endpoint is the a URL that acts as the points of contact  between an API client and an API  server. API clients send request to API endpoint in order to access the API's functionality and data.
  ## At first we going to create an API end point 
  ## Then we are going to access the API end point .
 `Routes` refers to the the process of determining how an application responds to a client request to a particular endpointpoinor URL, which is a path on the server . Function are known as route handler .
 ```Rust
 #[macro_use]
extern crate rocket;
#[get("/")]  // "/" this is root path of the rocket application. which is invoked when client makes the request.
             // GET is used by client to request data from the server . It is one of the famous method of the HTTP
fn index() ->String {
  String::from ("HI")
}
#[launch]
fn rocket() -> _ {
 rocket::build() // This is use to compile and build rocker application 
  .mount("/", routes![index]) // In context mount means attaching the set of routes with the specific path in the application.


}
 ```
 # Few key terms use in API 
`Address`
  - This configuration allow the speicifies the IP addres on which the Rocket server will listen for incoming connection .
   - Loopback = It simply means that it allow device to send and receive its own data packets. In this we send data to ourself in same system .
   The common port used in this is IPv4, 127.0.0.1 which can range upto  127.255.255.255.
`Port`
  - A port is virtual point where network connection start ans end .Port are software based and managed by computer'operating system . 
  - The port number specifies the the port number on which the rocket server will listen. 
  Port Number:8000  reserved for the http communication.
  Port Number: 8000
   TCP / UDP: TCP
   Delivery: Yes
   Protocol / Name: irdmi
   Port Description: iRDMI
   Virus / Trojan: No
 
`Workers`
The workers configuration specifies the number of worker threads that will be used to handle incoming HTTP requests concurrently.
Setting this to 16 means that the server can handle up to 16 requests concurrently.

# https://github.com/rwf2/Rocket/commit/5a4e66ec439411d30f16e5c045f8e4986f5883a4 
ned to revie in class 
```RUST
#[macro_use]
extern crate rocket;

use rocket::serde::json::{Json, Value};
use serde_json::json;

#[get("/")]
fn index() -> &'static str {
    "Welcome to the Rocket API!"
}

#[get("/users")]
fn get_users() -> Json<Value> {
    let users = json!([
        {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com"
        },
        {
            "id": 2,
            "name": "Jane Doe",
            "email": "jane@example.com"
        }
    ]);
    Json(users)
}

#[get("/users/<id>")]
fn get_user_by_id(id: u32) -> Json<Value> {
    let user = match id {
        1 => json!({
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com"
        }),
        2 => json!({
            "id": 2,
            "name": "Jane Doe",
            "email": "jane@example.com"
        }),
        _ => json!({"error": "User not found"}),
    };
    Json(user)
}

#[launch]
fn rocket() -> _ {
    rocket::build()
        .mount("/", routes![index, get_users, get_user_by_id])
}

```
```Rust

use actix_web::{web, App, HttpServer, Responder};

async fn index() -> impl Responder {
    "Hello world!"
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new().service(
            // prefixes all resources and routes attached to it...
            web::scope("/app")
                // ...so this handles requests for `GET /app/index.html`
                .route("/index.html", web::get().to(index)),
        )
    })
    .bind(("127.0.0.1", 8080))?
    .run()
    .await
}
```
# Methods
 # Basic URL for local host
 http://localhost:8080/
`Post`= This methods submits an entity to the specified resources.This may results in change in state or side effects on the server.
`Put` = 
`Get` = This methods request a represtation of the speicified resource.Requests using GET should only retrive data.
`Delete`=It delete the specified resource.
`Head` = This methods ask for a response identical to a get request,but without the response body.
`Patch`= It applies partial modification to a resource.
`Options`= The options methods describes the communication options for the target resource. 





# Dynamic paths 
 We can create path segments as a dynamic path using angel brackets. Arounds varible names in the route path.
 







